Command-Driven In-Memory Database (Thread-Safe, TTL Enabled)

This project implements a command-driven, thread-safe in-memory database written in Java. The system is designed to store key-value data in memory using integer keys and supports generic value types. It accepts user commands through standard input, processes them using a structured command parser, and executes them against the database engine. The implementation focuses on applying object-oriented design principles, multithreading, synchronization, lifecycle control, and exception handling to simulate the behavior of a lightweight database system.

The database supports commands such as PUT, GET, DELETE, START, STOP, and EXIT. Values can optionally be stored with a time-to-live (TTL), allowing entries to expire automatically after a specified duration. The command parser reads raw input, tokenizes it, validates command syntax, and converts it into structured command objects. This separation between parsing and execution improves maintainability, ensures clean validation, and prevents execution logic from being coupled with input handling.

Internally, the database stores data using a map structure that associates integer keys with entry objects. Each entry contains the stored value and an expiration timestamp when TTL is used. Initially, a HashMap combined with synchronized methods is used to ensure atomic operations across multiple threads. This approach guarantees safety but limits scalability due to coarse locking. In later stages, the design is improved using ConcurrentHashMap to increase performance and allow concurrent access with finer-grained locking while maintaining TTL correctness.

Expiration handling is implemented using both lazy and proactive strategies. Lazy expiration removes expired entries during GET operations by checking the stored expiry time against the current epoch time. Additionally, a background cleanup thread periodically scans the database and removes expired entries automatically. This hybrid approach balances simplicity and memory efficiency while demonstrating safe concurrent modification techniques.

The lifecycle of the database is controlled using a volatile boolean flag that determines whether the system is running or stopped. This ensures that state changes are immediately visible across threads without heavy synchronization. When the database is stopped, write operations such as PUT and DELETE are rejected, while read operations may return null or raise an exception depending on configuration. This demonstrates proper usage of volatile variables for visibility guarantees in concurrent environments.

Robust exception handling is incorporated through custom exception classes that signal invalid commands, invalid TTL values, stopped database states, and missing keys. This enables fail-fast behavior and produces meaningful feedback for debugging and user interaction. The system is also tested with multiple command executor threads to observe race conditions, validate synchronization strategies, and demonstrate thread-safe execution under concurrent workloads.

Overall, this project serves as a practical demonstration of designing a concurrent system from the ground up. It highlights key concepts such as separation of concerns, encapsulation, synchronization tradeoffs, concurrent collections, lifecycle management, and safe background processing. The final implementation showcases how a simple in-memory structure can evolve into a scalable, multithreaded system through incremental refinement and performance optimization.
